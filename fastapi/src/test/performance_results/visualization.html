<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Character ì„±ëŠ¥ ë¶„ì„</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        canvas { margin: 30px 0; }
        .stats { font-size: 16px; margin-bottom: 20px; }
        .table-container { max-height: 300px; overflow-y: auto; margin-top: 30px;}
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ccc; padding: 4px 8px; font-size: 13px; }
        th { background: #f0f0f0; }
        .chart-container { display: flex; gap: 40px; align-items: flex-start; }
    </style>
</head>
<body>
    <h1>Character-Llama ì„±ëŠ¥ ì‹œê°í™”</h1>
    <label for="csvFile">CSV íŒŒì¼ ì„ íƒ:</label>
    <input type="file" id="csvFile" accept=".csv">
    <div class="stats" id="userStats"></div>
    <canvas id="bubbleChart" width="900" height="400"></canvas>
    <canvas id="processTimeHist" width="900" height="300"></canvas>
    <canvas id="responseSizeHist" width="900" height="300"></canvas>
    <div class="ct-container">
        <canvas id="userOutcomeChart" width="900" height="300"></canvas>
    </div>
    <div class="table-container" id="failureTableContainer"></div>

    <script>
        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            
            return lines.slice(1).map(line => {
                const values = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        values.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                values.push(current.trim());
                
                const obj = {};
                headers.forEach((h, i) => {
                    let value = values[i] || '';
                    
                    // Boolean ê°’ë“¤ ì²˜ë¦¬
                    if (['success', 'is_retry_record', 'is_final_failure', 'is_final_success', 'error'].includes(h)) {
                        if (value === 'True' || value === 'true') {
                            value = true;
                        } else if (value === 'False' || value === 'false') {
                            value = false;
                        }
                    }
                    
                    // ìˆ«ì ê°’ë“¤ ì²˜ë¦¬
                    if (['response_time', 'retry_count', 'retry_after_seconds', 'response_size', 'process_time'].includes(h)) {
                        value = value === '' ? 0 : Number(value);
                    }
                    
                    obj[h] = value;
                });
                return obj;
            });
        }

        document.getElementById('csvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(evt) {
                const data = parseCSV(evt.target.result);
                debugData(data); // ë””ë²„ê¹… í•¨ìˆ˜ í˜¸ì¶œ
                drawBubbleChart(data);
                drawUserOutcomeChart(data);
                drawFailureTable(data);
                showUserStats(data);
                drawProcessTimeHist(data);
                drawResponseSizeHist(data);
            };
            reader.readAsText(file, 'utf-8');
        });

        function drawBubbleChart(data) {
            data.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            const chartData = data.map(row => ({
                x: new Date(row.timestamp),
                y: Number(row.response_time),
                user_id: row.user_id,
                status_code: row.status_code,
                success: row.success
            }));
            new Chart(document.getElementById('bubbleChart').getContext('2d'), {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'ì‘ë‹µ ì‹œê°„',
                        data: chartData,
                        backgroundColor: chartData.map(d =>
                            d.status_code === '200' ? '#4caf50' :
                            d.status_code === '429' ? '#f44336' :
                            d.status_code === '500' ? '#ff9800' : '#2196f3'
                        ),
                        pointRadius: 5,
                        borderColor: '#333'
                    }]
                },
                options: {
                    responsive: false,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: ctx => {
                                    const d = ctx.raw;
                                    return [
                                        `user_id: ${d.user_id}`,
                                        `ì‘ë‹µì‹œê°„: ${d.y}ì´ˆ`,
                                        `ì„±ê³µ: ${d.success}`,
                                        `ìƒíƒœì½”ë“œ: ${d.status_code}`
                                    ];
                                }
                            }
                        },
                        title: { display: true, text: 'ì‹œê°„ë³„ ì‘ë‹µ ì„±ëŠ¥ (Scatter Plot)' }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            title: { display: true, text: 'ì‹œê°' }
                        },
                        y: { title: { display: true, text: 'ì‘ë‹µ ì‹œê°„(ì´ˆ)' } }
                    }
                }
            });
        }

        function drawUserOutcomeChart(data) {
            const userMap = {};
            data.forEach(row => {
                if (!userMap[row.user_id]) userMap[row.user_id] = [];
                userMap[row.user_id].push(row);
            });

            let finalFailure = 0, retrySuccess = 0, directSuccess = 0;
            Object.values(userMap).forEach(logs => {
                const sorted = logs.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                const last = sorted[sorted.length - 1];
                
                // ìƒíƒœì½”ë“œ ê¸°ì¤€ìœ¼ë¡œ ë¶„ë¥˜
                const lastStatusCode = parseInt(last.status_code);
                
                if (lastStatusCode >= 500 && lastStatusCode < 600) {
                    finalFailure++; // 5xx: ì„œë²„ ì˜¤ë¥˜ (ìµœì¢… ì‹¤íŒ¨)
                } else if (sorted.some(r => r.retry_count > 0)) {
                    retrySuccess++; // 4xx: ì¬ì‹œë„ í›„ ì„±ê³µ
                } else {
                    directSuccess++; // 2xx: ë°”ë¡œ ì„±ê³µ
                }
            });

            new Chart(document.getElementById('userOutcomeChart').getContext('2d'), {
                type: 'pie',
                data: {
                    labels: ['5xx (ì„œë²„ ì˜¤ë¥˜)', '4xx (ì¬ì‹œë„ í›„ ì„±ê³µ)', '2xx (ë°”ë¡œ ì„±ê³µ)'],
                    datasets: [{
                        data: [finalFailure, retrySuccess, directSuccess],
                        backgroundColor: ['#f44336', '#2196f3', '#4caf50'] // 5xx: ë¹¨ê°•, 4xx: íŒŒë‘, 2xx: ë…¹ìƒ‰
                    }]
                },
                options: {
                    responsive: false,
                    plugins: {
                        title: { display: true, text: 'User ê²°ê³¼ ë¶„í¬ (ìƒíƒœì½”ë“œ ê¸°ì¤€)' }
                    }
                }
            });

            document.getElementById('userStats').innerHTML = `
                âœ… ì „ì²´ ìœ ì € ìˆ˜: <b>${Object.keys(userMap).length}</b><br>
                âŒ 5xx (ì„œë²„ ì˜¤ë¥˜): <b>${finalFailure}</b>ëª…<br>
                ğŸ” 4xx (ì¬ì‹œë„ í›„ ì„±ê³µ): <b>${retrySuccess}</b>ëª…<br>
                âœ”ï¸ 2xx (ë°”ë¡œ ì„±ê³µ): <b>${directSuccess}</b>ëª…
            `;
        }

        function drawFailureTable(data) {
            const cols = [
                'user_id','test_type','endpoint','character_name','status_code','response_time','success',
                'failure_reason','retry_count','retry_after_seconds','timestamp','response_size',
                'is_retry_record','is_final_failure','is_final_success','process_time'
            ];
            
            // ì‹¤íŒ¨(ì„±ê³µì´ ì•„ë‹ˆê±°ë‚˜), ì¬ì‹œë„(retry_count > 0), ë˜ëŠ” errorê°€ trueì¸ í–‰ë§Œ ì¶”ì¶œ
            // successê°€ falseì´ê±°ë‚˜, retry_count > 0ì´ê±°ë‚˜, is_final_failureê°€ trueì¸ ê²½ìš°
            const failures = data.filter(row => 
                row.success === false || 
                Number(row.retry_count) > 0 || 
                row.is_final_failure === true ||
                row.error === true  // error=trueì¸ ê²½ìš°ë„ í¬í•¨ (í˜„ì¬ëŠ” ì—†ìŒ)
            );
            
            if (failures.length === 0) {
                document.getElementById('failureTableContainer').innerHTML = '<b>ì‹¤íŒ¨/ì¬ì‹œë„ ë‚´ì—­ ì—†ìŒ</b>';
                return;
            }

            let html = `<h3>ì‹¤íŒ¨/ì¬ì‹œë„ ìƒì„¸ ë‚´ì—­ (ì´ ${failures.length}ê±´)</h3><table><thead><tr>`;
            cols.forEach(h => html += `<th>${h}</th>`);
            html += '</tr></thead><tbody>';
            failures.forEach(row => {
                html += '<tr>';
                cols.forEach(h => {
                    let cellValue = row[h];
                    // Boolean ê°’ë“¤ì„ ë¬¸ìì—´ë¡œ í‘œì‹œ
                    if (typeof cellValue === 'boolean') {
                        cellValue = cellValue.toString();
                    } else if (cellValue === null) {
                        cellValue = 'null';
                    }
                    html += `<td>${cellValue !== undefined && cellValue !== null ? cellValue : ''}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody></table>';
            document.getElementById('failureTableContainer').innerHTML = html;
        }

        function showUserStats(data) {
            // ì´ í•¨ìˆ˜ëŠ” drawUserOutcomeChartì—ì„œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
        }

        function drawProcessTimeHist(data) {
            // status_codeê°€ 200ì¸ ë°ì´í„°ë§Œ ì‚¬ìš©, ì»¬ëŸ¼ëª… ìˆ˜ì •
            const values = data
                .filter(row => row.status_code === '200')
                .map(row => Number(row.process_time)) // Process_time -> process_timeìœ¼ë¡œ ìˆ˜ì •
                .filter(v => !isNaN(v) && v > 0);

            console.log('Process time values:', values.slice(0, 10)); // ë””ë²„ê¹…ìš©

            new Chart(document.getElementById('processTimeHist').getContext('2d'), {
                type: 'bar',
                data: {
                    labels: getBins(values, 20).labels,
                    datasets: [{
                        label: 'Process Time (ì´ˆ) ë¶„í¬ (200ë§Œ)',
                        data: getBins(values, 20).counts,
                        backgroundColor: '#2196f3'
                    }]
                },
                options: {
                    responsive: false,
                    plugins: {
                        title: { display: true, text: 'Process Time ë¶„í¬ (status_code=200, 0ì´ˆ ì œì™¸)' }
                    },
                    scales: {
                        x: { title: { display: true, text: 'process_time (ì´ˆ)' } },
                        y: { title: { display: true, text: 'ë¹ˆë„' }, beginAtZero: true }
                    }
                }
            });
        }

        function drawResponseSizeHist(data) {
            // status_codeê°€ 200ì¸ ë°ì´í„°ë§Œ ì‚¬ìš©
            const values = data
                .filter(row => row.status_code === '200')
                .map(row => Number(row.response_size))
                .filter(v => !isNaN(v) && v > 0);

            new Chart(document.getElementById('responseSizeHist').getContext('2d'), {
                type: 'bar',
                data: {
                    labels: getBins(values, 20).labels,
                    datasets: [{
                        label: 'Response Size (bytes) ë¶„í¬ (200ë§Œ)',
                        data: getBins(values, 20).counts,
                        backgroundColor: '#4caf50'
                    }]
                },
                options: {
                    responsive: false,
                    plugins: {
                        title: { display: true, text: 'Response Size ë¶„í¬ (status_code=200, 0 ì œì™¸)' }
                    },
                    scales: {
                        x: { title: { display: true, text: 'response_size (bytes)' } },
                        y: { title: { display: true, text: 'ë¹ˆë„' }, beginAtZero: true }
                    }
                }
            });
        }

        // íˆìŠ¤í† ê·¸ë¨ bin ê³„ì‚° í•¨ìˆ˜
        function getBins(values, binCount) {
            if (values.length === 0) return { labels: [], counts: [] };
            const min = Math.min(...values);
            const max = Math.max(...values);
            const step = (max - min) / binCount;
            const bins = Array(binCount).fill(0);
            values.forEach(v => {
                let idx = Math.floor((v - min) / step);
                if (idx === binCount) idx = binCount - 1;
                bins[idx]++;
            });
            const labels = Array(binCount).fill(0).map((_, i) =>
                `${(min + i * step).toFixed(1)}~${(min + (i + 1) * step).toFixed(1)}`
            );
            return { labels, counts: bins };
        }

        // ë””ë²„ê¹…ì„ ìœ„í•œ ì¶”ê°€ í•¨ìˆ˜
        function debugData(data) {
            console.log('=== ë°ì´í„° ë””ë²„ê¹… ì •ë³´ ===');
            console.log('ì´ ë°ì´í„° ìˆ˜:', data.length);
            console.log('ì²« ë²ˆì§¸ í–‰:', data[0]);
            console.log('ì»¬ëŸ¼ëª…ë“¤:', Object.keys(data[0]));
            
            // Success ë¶„ì„
            const successStats = data.reduce((acc, row) => {
                if (row.success === true) acc.true++;
                else if (row.success === false) acc.false++;
                else acc.other++;
                return acc;
            }, { true: 0, false: 0, other: 0 });
            console.log('Success í†µê³„:', successStats);
            
            // Error ë¶„ì„
            const errorStats = data.reduce((acc, row) => {
                if (row.error === true) acc.true++;
                else if (row.error === false) acc.false++;
                else if (row.error === null) acc.null++;
                else acc.other++;
                return acc;
            }, { true: 0, false: 0, null: 0, other: 0 });
            console.log('Error í†µê³„:', errorStats);
            
            // Status code ë¶„ì„
            const statusStats = {};
            data.forEach(row => {
                statusStats[row.status_code] = (statusStats[row.status_code] || 0) + 1;
            });
            console.log('Status Code í†µê³„:', statusStats);
            
            // Retry ë¶„ì„
            const retryStats = {};
            data.forEach(row => {
                const retryCount = Number(row.retry_count);
                retryStats[retryCount] = (retryStats[retryCount] || 0) + 1;
            });
            console.log('Retry Count í†µê³„:', retryStats);
            
            // Process time ë¶„ì„
            const processTimeValues = data
                .map(row => Number(row.process_time))
                .filter(v => !isNaN(v) && v > 0);
            console.log('Process time ìœ íš¨ ê°’ ìˆ˜:', processTimeValues.length, '/ ì „ì²´:', data.length);
            console.log('Process time ìƒ˜í”Œ:', processTimeValues.slice(0, 5));
            
            // Final failure ë¶„ì„
            const finalFailureCount = data.filter(row => row.is_final_failure === true).length;
            console.log('ìµœì¢… ì‹¤íŒ¨(is_final_failure=true) ìˆ˜:', finalFailureCount);
        }
    </script>
</body>
</html>
